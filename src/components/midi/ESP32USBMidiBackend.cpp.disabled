#include "ESP32USBMidiBackend.h"
#include <iostream>

ESP32USBMidiBackend::ESP32USBMidiBackend() {
    // Constructor
}

ESP32USBMidiBackend::~ESP32USBMidiBackend() {
    cleanup();
}

bool ESP32USBMidiBackend::initialize() {
#ifdef ESP32_BUILD
    try {
        // Create and initialize USB MIDI interface using Control Surface
        usb_midi_ = new USBMIDI_Interface();
        
        // Begin the Control Surface library (this initializes USB MIDI)
        Control_Surface.begin();
        
        initialized_ = true;
        status_ = ConnectionStatus::CONNECTED;
        
        std::cout << "[ESP32 USB MIDI] Initialized using Control Surface library" << std::endl;
        std::cout << "[ESP32 USB MIDI] Device should appear as USB MIDI device when connected" << std::endl;
        return true;
        
    } catch (const std::exception& e) {
        std::cout << "[ESP32 USB MIDI] Initialization failed: " << e.what() << std::endl;
        status_ = ConnectionStatus::ERROR;
        return false;
    }
#else
    // Desktop simulation mode
    std::cout << "[ESP32 USB MIDI] Simulation mode (desktop)" << std::endl;
    initialized_ = true;
    status_ = ConnectionStatus::CONNECTED;
    return true;
#endif
}

void ESP32USBMidiBackend::cleanup() {
    if (!initialized_) return;
    
#ifdef ESP32_BUILD
    if (usb_midi_) {
        delete usb_midi_;
        usb_midi_ = nullptr;
    }
#endif
    
    initialized_ = false;
    status_ = ConnectionStatus::DISCONNECTED;
    std::cout << "[ESP32 USB MIDI] Cleaned up" << std::endl;
}

UnifiedMidiManager::ConnectionStatus ESP32USBMidiBackend::getStatus() const {
    return status_;
}

void ESP32USBMidiBackend::sendMessage(uint8_t status, uint8_t data1, uint8_t data2) {
    if (!initialized_ || status_ != ConnectionStatus::CONNECTED) {
        return;
    }
    
#ifdef ESP32_BUILD
    if (usb_midi_) {
        // Send 3-byte MIDI message via USB using Control Surface
        MIDIMessage_3B msg = {status, data1, data2};
        usb_midi_->send(msg);
    }
#else
    // Desktop simulation
    std::cout << "[ESP32 USB MIDI] 0x" << std::hex 
              << (int)status << " 0x" << (int)data1 << " 0x" << (int)data2 << std::dec << std::endl;
#endif
    
    messages_sent_++;
}

void ESP32USBMidiBackend::sendMessage(uint8_t status) {
    if (!initialized_ || status_ != ConnectionStatus::CONNECTED) {
        return;
    }
    
#ifdef ESP32_BUILD
    if (usb_midi_) {
        // Send single-byte MIDI message via USB using Control Surface
        MIDIMessage_1B msg = {status};
        usb_midi_->send(msg);
    }
#else
    // Desktop simulation
    std::cout << "[ESP32 USB MIDI] 0x" << std::hex << (int)status << std::dec << std::endl;
#endif
    
    messages_sent_++;
}

void ESP32USBMidiBackend::update() {
    if (!initialized_) return;
    
#ifdef ESP32_BUILD
    // Update Control Surface (this processes USB MIDI input/output)
    Control_Surface.loop();
    
    // Check for incoming messages
    if (usb_midi_) {
        // Note: Control Surface handles incoming messages via callbacks
        // We would need to set up a callback system to capture them
    }
#endif
}

void ESP32USBMidiBackend::handleIncomingMessage(uint8_t status, uint8_t data1, uint8_t data2) {
    // This would be called by a Control Surface callback
    // TODO: Forward to UnifiedMidiManager callback system
    messages_received_++;
}
